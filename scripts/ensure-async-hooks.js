#!/usr/bin/env node
/**
 * Ensures that the Cloudflare Pages bundle contains a stub implementation of `async_hooks`
 * so that edge functions can "require" it without failing at runtime.
 */
const fs = require("fs");
const path = require("path");

const OUTPUT_DIR = path.join(
  process.cwd(),
  ".vercel",
  "output",
  "functions",
  "__next-on-pages-dist__",
  "functions"
);

const OUTPUT_FILE = path.join(OUTPUT_DIR, "async_hooks.js");
const WORKER_FILE = path.join(
  process.cwd(),
  ".vercel",
  "output",
  "static",
  "_worker.js",
  "index.js"
);
const EDGE_FUNC_FILE = path.join(
  process.cwd(),
  ".vercel",
  "output",
  "functions",
  "[language].func",
  "index.js"
);
const HEADER = `/**
 * Generated by scripts/ensure-async-hooks.js
 * Lightweight polyfill providing the bits of async_hooks required by Next.js on Cloudflare Workers.
 */
`;

const SOURCE = `${HEADER}
class SimpleAsyncLocalStorage {
  constructor() {
    this._currentStore = undefined;
    this._enterStore = undefined;
    this._enabled = true;
  }

  getStore() {
    return this._currentStore ?? this._enterStore;
  }

  disable() {
    this._enabled = false;
    this._currentStore = undefined;
    this._enterStore = undefined;
  }

  enable() {
    this._enabled = true;
  }

  enterWith(store) {
    if (!this._enabled) return;
    this._enterStore = store;
    this._currentStore = store;
  }

  run(store, callback, ...args) {
    if (!this._enabled) {
      return callback(...args);
    }
    const previous = this._currentStore;
    this._currentStore = store;
    try {
      return callback(...args);
    } finally {
      this._currentStore = previous;
    }
  }

  exit(callback, ...args) {
    const previous = this._currentStore;
    this._currentStore = undefined;
    try {
      return callback(...args);
    } finally {
      this._currentStore = previous;
    }
  }

  static snapshot() {
    throw new Error("AsyncLocalStorage.snapshot is not implemented in this polyfill.");
  }
}

class AsyncResource {
  constructor(type) {
    this.type = type;
  }

  runInAsyncScope(fn, thisArg, ...args) {
    return fn.apply(thisArg, args);
  }

  emitDestroy() {
    // noop
  }
}

const asyncHooks = {
  AsyncLocalStorage: SimpleAsyncLocalStorage,
  AsyncResource,
};

module.exports = asyncHooks;
module.exports.AsyncLocalStorage = SimpleAsyncLocalStorage;
module.exports.AsyncResource = AsyncResource;
`;

const EDGE_POLYFILL_HEADER = `const __asyncHooksPolyfill = (() => {
class SimpleAsyncLocalStorage {
  constructor() {
    this._currentStore = undefined;
    this._enterStore = undefined;
    this._enabled = true;
  }
  getStore() {
    return this._currentStore ?? this._enterStore;
  }
  disable() {
    this._enabled = false;
    this._currentStore = undefined;
    this._enterStore = undefined;
  }
  enable() {
    this._enabled = true;
  }
  enterWith(store) {
    if (!this._enabled) return;
    this._enterStore = store;
    this._currentStore = store;
  }
  run(store, callback, ...args) {
    if (!this._enabled) {
      return callback(...args);
    }
    const previous = this._currentStore;
    this._currentStore = store;
    try {
      return callback(...args);
    } finally {
      this._currentStore = previous;
    }
  }
  exit(callback, ...args) {
    const previous = this._currentStore;
    this._currentStore = undefined;
    try {
      return callback(...args);
    } finally {
      this._currentStore = previous;
    }
  }
  static snapshot() {
    throw new Error("AsyncLocalStorage.snapshot is not implemented in this polyfill.");
  }
}
class AsyncResource {
  constructor(type) {
    this.type = type;
  }
  runInAsyncScope(fn, thisArg, ...args) {
    return fn.apply(thisArg, args);
  }
  emitDestroy() {}
}
return { AsyncLocalStorage: SimpleAsyncLocalStorage, AsyncResource };
})();\n`;

const ALS_SNIPPET = `
\tconst __ALSes_PROMISE__ = Promise.resolve().then(() => {
\t\tclass SimpleAsyncLocalStorage {
\t\t\tconstructor() {
\t\t\t\tthis._currentStore = undefined;
\t\t\t\tthis._enterStore = undefined;
\t\t\t\tthis._enabled = true;
\t\t\t}
\t\t\tgetStore() {
\t\t\t\treturn this._currentStore ?? this._enterStore;
\t\t\t}
\t\t\tdisable() {
\t\t\t\tthis._enabled = false;
\t\t\t\tthis._currentStore = undefined;
\t\t\t\tthis._enterStore = undefined;
\t\t\t}
\t\t\tenable() {
\t\t\t\tthis._enabled = true;
\t\t\t}
\t\t\tenterWith(store) {
\t\t\t\tif (!this._enabled) return;
\t\t\t\tthis._enterStore = store;
\t\t\t\tthis._currentStore = store;
\t\t\t}
\t\t\trun(store, callback, ...args) {
\t\t\t\tif (!this._enabled) {
\t\t\t\t\treturn callback(...args);
\t\t\t\t}
\t\t\t\tconst previous = this._currentStore;
\t\t\t\tthis._currentStore = store;
\t\t\t\ttry {
\t\t\t\t\treturn callback(...args);
\t\t\t\t} finally {
\t\t\t\t\tthis._currentStore = previous;
\t\t\t\t}
\t\t\t}
\t\t\texit(callback, ...args) {
\t\t\t\tconst previous = this._currentStore;
\t\t\t\tthis._currentStore = undefined;
\t\t\t\ttry {
\t\t\t\t\treturn callback(...args);
\t\t\t\t} finally {
\t\t\t\t\tthis._currentStore = previous;
\t\t\t\t}
\t\t\t}
\t\t\tstatic snapshot() {
\t\t\t\tthrow new Error("AsyncLocalStorage.snapshot is not implemented in this polyfill.");
\t\t\t}
\t\t}
\t\tclass AsyncResource {
\t\t\tconstructor(type) {
\t\t\t\tthis.type = type;
\t\t\t}
\t\t\trunInAsyncScope(fn, thisArg, ...args) {
\t\t\t\treturn fn.apply(thisArg, args);
\t\t\t}
\t\t\temitDestroy() {}
\t\t}
\t\tconst AsyncLocalStorage = SimpleAsyncLocalStorage;
\t\tglobalThis.AsyncLocalStorage = AsyncLocalStorage;
\t\tconst envAsyncLocalStorage = new AsyncLocalStorage();
\t\tconst requestContextAsyncLocalStorage = new AsyncLocalStorage();
\t\tglobalThis.process = {
\t\t\tenv: new Proxy(
\t\t\t\t{},
\t\t\t\t{
\t\t\t\t\townKeys: () => Reflect.ownKeys(envAsyncLocalStorage.getStore()),
\t\t\t\t\tgetOwnPropertyDescriptor: (_, ...args) =>
\t\t\t\t\t\tReflect.getOwnPropertyDescriptor(envAsyncLocalStorage.getStore(), ...args),
\t\t\t\t\tget: (_, property) => Reflect.get(envAsyncLocalStorage.getStore(), property),
\t\t\t\t\tset: (_, property, value) => Reflect.set(envAsyncLocalStorage.getStore(), property, value),
\t\t\t\t}
\t\t\t),
\t\t};
\t\tglobalThis[Symbol.for('__cloudflare-request-context__')] = new Proxy(
\t\t\t{},
\t\t\t{
\t\t\t\townKeys: () => Reflect.ownKeys(requestContextAsyncLocalStorage.getStore()),
\t\t\t\tgetOwnPropertyDescriptor: (_, ...args) =>
\t\t\t\t\tReflect.getOwnPropertyDescriptor(requestContextAsyncLocalStorage.getStore(), ...args),
\t\t\t\tget: (_, property) => Reflect.get(requestContextAsyncLocalStorage.getStore(), property),
\t\t\t\tset: (_, property, value) => Reflect.set(requestContextAsyncLocalStorage.getStore(), property, value),
\t\t\t}
\t\t);
\t\treturn { envAsyncLocalStorage, requestContextAsyncLocalStorage, AsyncResource };
\t}).catch(() => null);
`;

function createPolyfillFile() {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  fs.writeFileSync(OUTPUT_FILE, SOURCE, "utf8");
  console.log(`[async_hooks] Polyfill written to ${OUTPUT_FILE}`);
}

function patchWorker() {
  if (!fs.existsSync(WORKER_FILE)) {
    console.warn(`[async_hooks] Worker file not found at ${WORKER_FILE}, skipping patch.`);
    return;
  }

  const workerSource = fs.readFileSync(WORKER_FILE, "utf8");
  const marker = `const __ALSes_PROMISE__ = import('node:async_hooks')`;

  if (!workerSource.includes(marker)) {
    console.warn("[async_hooks] Worker did not contain async_hooks import marker; skipping patch.");
    return;
  }

  const patched = workerSource.replace(
    /const __ALSes_PROMISE__ = import\('node:async_hooks'\)[\s\S]+?\.catch\(\(\) => null\);\n\t/u,
    `${ALS_SNIPPET}\n\t`
  );

  fs.writeFileSync(WORKER_FILE, patched, "utf8");
  console.log("[async_hooks] Patched worker bootstrap to use inline AsyncLocalStorage polyfill.");
}

function patchEdgeFunction() {
  if (!fs.existsSync(EDGE_FUNC_FILE)) {
    console.warn(`[async_hooks] Edge function file not found at ${EDGE_FUNC_FILE}, skipping patch.`);
    return;
  }

  let source = fs.readFileSync(EDGE_FUNC_FILE, "utf8");
  if (!source.includes("__asyncHooksPolyfill")) {
    source = EDGE_POLYFILL_HEADER + source;
  }
  const replaced = source.replace(/require\(["']node:async_hooks["']\)/g, "__asyncHooksPolyfill");
  if (replaced !== source) {
    fs.writeFileSync(EDGE_FUNC_FILE, replaced, "utf8");
    console.log("[async_hooks] Patched edge function bundle to inline async_hooks polyfill.");
  } else {
    console.log("[async_hooks] Edge function bundle already polyfilled.");
  }
}

createPolyfillFile();
patchWorker();
patchEdgeFunction();
